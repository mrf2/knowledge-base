# Intel 8051 Microcontroller

## ISR - Interrupt Service Routine
On the 8051, an ISR is a special function that runs automatically when an ***event occurs*** (*timer overflow, serial byte received, external pin change, etc.*). Instead of main loop constantly checking flags, the hardware **jumps to a fixed memory vector***.

 * Why Important?
   * Digital clocks (timers generate periodic interrupts)
   * Communication stacks (UART/serial interrupts)
   * Small OS kernels (tick interrupts, context switching)
 * **Reset Interrupt, Vector Address - `0x0000`, Priority - Highest**

|Vector Number|Address|Interrupt Name/Interrupt Source|Interrupt Flag|Priority Number|
|---|---|---|---|---|
|0|`0x0003`|External INT0 (P3.2)|`IE0`|1|
|1|`0x000B`|Timer0 TF0 Overflow|`TF0`|2|
|2|`0x0013`|Extenal Interrupt INT1 (P3.3)||3|
|4|`0x001B`|Timer1 TF1|`TF1`|-|4|
|5|`0x0033`|PCA (CF or CCFn)|-|5|
|6|`0x0023`|UART (RI or TI)|-|6|
|7|`0x002B`|Timer2 (TF2)|-|7|
|8|`0x0043`|ADC (ADCI)|-|8|
|9|`0x0053`|SPI Interrupt|-|9|

## Instructions
 * **Jump instructions**
   * **LJMP** (Long Jump): 3 bytes $\rightarrow$ `opcode (1B)` + `16-bit address (2B)` $\rightarrow$ total 3 bytes, full **64 KB address range**.
   * **AJMP** (Absolute Jump): 2 bytes $\rightarrow$ `opcode (1B)` + `11-bit address (embedded in opcode + address byte)` $\rightarrow$ can only jump **within the same 2KB page**.
   * **SJMP** (Short Jump): 2 bytes $\rightarrow$ `opcode (1B)` + signed 8-bit offset ($\pm$ 127 bytes)
